1. node.js 의 역할
기존의 JS 는 브라우저 안에서만 동작하는 언어였으나 (브라우저가 컴파일러 역할 하는)
node.js 를 쓰게 되면서 브라우저 밖에서도 컴파일이 가능하게 하도록 만들었다.
즉, 브라우저에 종속되지 않는 JS 를 만듬 (브라우저 간 서로다른 규격의 통합)

2. node.js 를 쓰는 경우
- front, back 둘 다 JS 로 하고 싶은 경우
- node.js 는 거대한 패키지가 아님
(spring 같은 경우 이것저것 상당히 많이 들어가는데, node.js 의 경우 그냥 껍데기만 던져준다고 보면됨
그 껍데기 안에서 JS 개발자가 알아서 추가하는 방식, 상대적으로 그리고 배우기가 더 쉬움 (많이 있는게 아니다보니)
node.js 를 제외한 spring, lalavel, django 등 은 뭔가를 쭉 이론적인것을 배우고 나서 해야 사용이 가능)

- 정적인 웹 사이트를 만들고자 하는 경우
웹 사이트가 매우 동적이거나 interactive 한 사이트가 아니라 그저 정보 보여주기만 하는 그런 류의 웹사이트면
nodejs 를 사용하는것이 매우 빠르게 작성하는데 편리하고
spring 같은 경우는 매우 여러가지 들어가는게 많기 때문에, 가벼운 사이트를 만들고자 한다면 적합하지 않을 수도 있다
그래서 큰 기업에서만 쓰는가보다.

3. controller
MVC 중 C 부분
서버와의 통신을 담당 GET POST PUT/PATCH DELETE 를 할 수 있게 해줌
(cf) : REST API : URL(resource), HTTP method(verb), Representations 를 의미함 , CRUD 와는 다른 개념임)

4. babel 은 최신의 자바스크립트 코드를 구식의 코드로 변환해주어 컴파일러(브라우저) 가 이해할 수 있도록 변환시켜준다.

5. app.listen() 의 의미
listen 은 웹 서버가 응답 대기 상태로 진입하기 시작해라 라는 의미이다
서버가 직접적인 req, res 작업을 하기 이전에 대기 상태에 가라는 의미

6. 구식 JS 코드와 신식 JS 코드 간 차이 (ES6 버젼 이후)
function name(args) {
    statements
}

위에 처럼 정의한게 ES6 이전의 JS 라면

const name = (args) => {
    statements
}

같이 화살표로 정의된 함수가 ES6 버젼 이후 부터의 JS 문법임

7. nodemon
nodemon 은 express 서버를 구동할때 어떤 수정 사항이 있을때 마다 서버를 껐다가 다시켜야만
새로고침이 적용되어서 내용 업데이트가 가능하다
그러나 이런 방식은 데이터 손실을 불러올 수 있으므로
이를 방지하게 해주는 것이 nodemon 이다
근데 프로젝트 개발에 필요한 도구라기 보다는 개발자가 편하게 작성하기위한 도구에 더 가깝다
그래서 dependencies 에 추가되지 않게 하는게 좋다
그렇게 하기 위해선
npm install nodemon -D 같이 작성해주면 
package.json 에 "devDependencies" 라는 새로운 entry point 가 작성되어서
별도로 패키지 관리를 하게 된다

8. --delay n
package.json 에 start 부분에 위 명령어를 추가해 준것은
nodemon 이 웹 페이지 데이터를 새로고침 할때마다 업로드하는것 그리고 
babel 에 의해서 코드가 구JS 코드로 변환되는것 
이 두작업에 의해서 두번 새로 고침 되기 때문에 
log 를 볼 때 개발자가 헷갈리게 만들 수 있다
그래서, 이 두번 실행되는 것을 방지 하고자 --delay n 옵션을 추가해 준다 (n은 시간초)

9. middleware
middleware 란 request 와 response 사이의 중간 매개체 역할을 하는 함수의 일종이다
app.get('/', middleware, nextFunc);
같이 정의가 되어있다고 쳤을때,
유저가 홈 에 접속햇을때, middleware 를 먼저 처리하고 그 다음에 middleware 에 정의되어 있는 
next 여부에 따라서 nextFunc 을 시행할지 말지를 결정한다.
이 middleware 는 사용자의 로그인 여부, 파일 업로드 관리 등 다양한 기능을 수행할 수 있다
express 에서의 웹은 양파와 같다고 생각하면 된다 (요청 - middleware - 수행) 사이의 수많은 middleware 로 구성

10. 모든 주소에 공통적으로 적용할 middleware
CRUD 명령어를 사용하기에 앞서서
JS 는 인터프리터 언어이기 때문에 한줄 한줄 순차적으로 실행하는게 원칙이다 (그러나 비동기 기능이 있어서 다르게 작용한다고 글을 봄, 뭐가 맞는지 확인하기)
app.get(~~)
app.put(~~) 같은 명령어 수행 이전에
app.use(middleware) 를 윗줄에 정의해 두면 CRUD 실행 이전에 middleware를 실행하게 된다
이때 실행되는 middleware 는 모든 웹 사이트에 공통적으로 적용된다.

11. morgan
morgan 은 express 서버 실행시에 개발자에게 log 정보를 남겨주는 미들웨어 이다
arg 옵션에 따라서 다양한 로그 정보를 내포한다

12. helmet
helmet 은 express 서버 실행시에 nodejs 에 보안성을 좀 더 추가시켜주는 미들웨어 이다

13. body-parser, cookie-parser
이 두 미들웨어는 각각 body, cookie 로 부터 정보를 얻어오게 해주는 미들웨어이다
구체적인 사용법은 강의 후반부에 나올 것 같다

14. cookie 와 session
HTTP 는 기본적으로 server-side 에서는 stateful 한 특징이 있고 (상태 정보를 가지며, 데이터가 실질적으로 저장됨)
반면에, client-side 에서는 stateless 한 성질을 갖고 있다 (상태정보도 안갖고 있으며, 데이터가 저장되지도 않음 (브라우저 종료시에 데이터 사라짐))
그러나, 장바구니, 로그인을 통한 정보확인 서비스 등 개별 클라이언트만 갖고 있는 고유한 데이터에 대한 서비스가 필요해 짐에 따라서
client-side 에서도 stateful service 가 필요해졌다.
그래서 서버에만 정보를 저장할게 아니라 클라이언트도 정보를 저장하자는 의미에서 등장한게 바로 cookie 이다
서버로부터 클라이언트가 쿠키를 받게되면, 저장매체나 메인메모리에 적재되며,
쿠키에는 쿠키의이름, 저장된 값, 쿠키의 허용 도메인 범위, 쿠키의 만료일 등 의 정보가 들어가 있다.

그러나 쿠키의 단점은 쿠키의 양이 늘어 날 수록 클라이언트가 요청하는 트래픽 양이 증가하게 되고 이에 따라 트래픽 증가로 서버 간 통신시에 지장을 줄 수 있다
(양이 많아질 경우 DDoS attack)
또한 쿠키에 클라이언트의 민감한 정보(결제 정보, 결제 수단 등) 가 들어 있을 경우
보안상의 문제를 줄 수 있다

그래서 등장한게 session 이다.

session 은 쿠키에 session id 값만 넘겨주고 (클라이언트로), 기존에 쿠키에 저장되던 클라이언트 단의 정보를 서버 DB 에 저장하도록 하는 방식이다

과도하게 세션을 많이 사용하게 될 경우, 서버에 무리를 줄 수 가 있기 때문에 
사용하고자 하는 시스템에 따라서 적합한 설계를 해야한다.

15. index.js 를 app.js 로 바꿈
(프로젝트 규모가 커질 수록 기능적인 분할을 확실히 해두는게 좋음)

app.js 에서 설정한 express 관련 설정들(미들웨어나 req, res 등) 을 하나의 오브젝트 형식으로 
export default app; 을 하게 되었기 때문에, init.js 에서 import app from "./app"; 이 가능함

init.js 는 서버 구동을 할때 시작 대기 상태로 만들어주는 역할이고 (포트번호에 접속만하고 명령을 대기 받는 상태로 진입시킴)
app.js 는 서버 구동시에 필요한 환경설정들을 해주는 동시에(미들웨어로 환경설정해줌) 컨트롤러와 연결을 시켜주는 역할을 함

16. export default 와 export 
export const name = ~ ; 같이 하나의 변수만을 export 를 하게 되면 import 를 할 때
import { name } from 파일명 으로 작성해야 하며
반면에
export default name; 
으로 작성한 경우
import nickname from 파일명 으로 작성해야 한다

하나만 export 하는 경우 {} 를 붙여서 가져오고
default 를 쓸 경우 {} 없이 작성한다 

default 는 파일 단위로 export 하는것

17. use
use 는 어떤 경로에 접근 했을경우 매개변수로 넣은 라우터 전체를 사용한다 라는 의미로 쓰인다
(매개변수가 라우터가 아니라 다른 것이어도 가능, 미들웨어 등)
use 를 사용해서 특정경로에 들어갔을때 어떤 라우터를 사용하겠다 라고 정의하면 그 경로가 home 경로가 됨
예를들어
app.use("/user", routerOne);
이면 
routerOne 에 routerOne.get("/", (req, res) => res.send("good")); routerOne.get("/two", (req, res) => res.send("two good"));
같이 정의가 되어있다면, routerOne 의 홈주소는 user 이며 two 에 접속할때는 /user/two 로 접속해야 한다.

18. MVC
M : model (data 를 의미하며 DB 를 생각하면 됨)
V : view (데이터를 어떻게 보여줄 것인가)
C : controller (데이터를 찾도록 도와주는 함수)


18. router 
router URL 처리만 담당하며,
controller 는 spring 과 마찬가지로 특정 주소값에 부합하는 랜더링 처리를 담당한다.

19. 
spring boot 와 express 의 가장 큰 차이점은 
튜닝 여부와 분할 정도 이다
spring 은 express 와 다르게 주소, 주소에 대한 함수를 controller 로 같이 정의하는데 반해서
express 는 주소 따로 주소에 대한 함수 따로 (routes, controller) 로 정의한다
분할의 정도가 다른 것일 뿐 근본적인 원리는 동일하다.

20 arrow function
함수형 언어에서 return 할때는 기본적으로 implicit 한 성질을 갖고 있어서
별도로 return something 이라고 써주지 않고 something 만 써줘도 리턴이 가능했다
그러나 중괄호 {} 을 쓸 경우엔 return 을 꼭 써줘야 한다 explicit 으로 바뀜


21. pug
express 의 view engine 인 pug 를 사용하려면
app.set("view engine", "pug"); 라고 정의 해줘야 하며
express 는 기본적으로 view 에 대한 파일 경로 설정이 views 폴더 내에 view 관련 파일이 있는 것으로 간주함
그래서 views 폴더를 만들어줘야 하며, 이를 URL 에 맞춰서 랜더링 해줄려면
컨트롤러 파일에서 작성시에 res.render("pug file name", 기타 옵션) 의 형식으로 정의해야만 랜더링이 가능하다.

22. pug 에 js 코드 추가
pug 에 js 코드를 추가하려면 #{js code} 를 작성하면 된다.

23. view template 에서 routes 에 접근하는 법
템플릿 전체에 적용되는 방식으로 접근하느냐
아니면 일부 템플릿만 적용되는 방식으로 접근하느냐 에 따라 나뉜다

전체에 적용되도록 접근하려면 미들웨어를 이용해야 한다.

(참고로 미들웨어는 포토샵의 레이어와 같은 느낌이다. 위에서 아래로 적용됨)

미들웨어를 새로 만들려면
app.use(함수이름); 같은 방식으로 만들면 되고
함수 작성은 ES6 방식의 화살표 함수로 하든 구형 함수로 하든 무관
그리고 divide and conquer 가 원칙이므로, 함수를 갖는 js 파일 따로
app.use() 를 하는 함수 따로 분리하자.

(참고로, import 는 알파벳 순으로 나열하는게 좋은 습관)

그리고 다음 단계로 미들웨어에서 res.locals 를 설정해 준다
이 locals 는 미들웨어의 지역 변수이자 템플릿의 전역 변수 역할을 한다

res.locals.title = "abc";

같이 설정하고 template 에 #{title} 이라고 설정하면 
템플릿에 들어간 title 변수는 abc 로 치환되어 나타난다.

주의해야할 점은 이 미들웨어 작성시에 반드시 next() 를 써야한다는 것이다
이 미들웨어가 환경설정용 미들웨어와 라우터용 코드 사이에 있기 때문이다.

위에 까지는 전역 변수로써 템플릿에 변수를 넣는 방법이 었다면

각 템플릿 만이 갖는 지역 변수를 갖게 해주려면 어떻게 해야하는가
이 경우는 각 템플릿에 일치하는 주소값을 갖는 controller 에서 처리를한다
controller 에 res.render(pugName, {Obj});
두번째 멤버 변수가 바로 객체 (Object) 를 넣을 수 잇는 변수로써
여기에 변수명(키값) : value 형태로 넣을 수 있다.

이 프로젝트에서는 
pageTitles : "Home" 같은 방식으로 값을 넣었다.

정리하면
전역 변수 선언 : middleware.js 파일 생성 후 res.locals.name = "~~"; 로 선언
지역 변수 선언 : 각 controller 에 두번째 인자 Obj 객체를 추가.

24. form 태그 action attribute
이 속성은 (props) 매칭할 url 주소를 설정하는 방법이고
method="get" 에서 method 는 HTTP method 를 설정하는 부분 (get, post, patch, delete)


25. 템플릿에서 form 형태로 다른 템플릿에 값 넘겨주기
이런 방법을 구현할때는 가장먼저
console.log(req); 형식으로 값을 넘겨줄때, req obj 에서 어떤 부분에 변수로써 저장되는지 파악하고
그 다음에 어디에 저장되있는지 봤다면, obj 의 변수를 활용하여 일을 처리한다.

26. const term = req.query.term 의 ECMAscript 버젼 처리
ES6 버젼으로 위 변수를 처리하면 다음과 같다 const { query : {term} } = req;
또는 const searchingBy = req.query.term 을 
const { query : {term : searchingBy}} = req; 같이 처리할 수도 있다.
이렇게 선언한 변수를 res.render 에서 두번째 매개변수 Obj 에 추가해준다.
videoControllers.js 에 보면 pageTitles 말고 하나 변수가 더 추가 됫음을 알 수 있다.


27. 주소 접속이 잘못되는 경우
1. controller 에 제대로 매칭이 되었는지 확인한다
2. 코드의 작성 순서를 파악한다 (인터프리터 언어이므로 순차적으로 실행함)


28. mixins
html 코드를 복사 붙여넣기로 재사용하지 않고 다른 방식으로 재사용하는 것을 mixins 이라함
mixins 은 웹 사이트에서 자주 반복되는 html 코드를 담는 역할을 함
pug 에서 mixin 은 일종의 함수 같은 역할을 함

29. bodyparser
bodyparser 는 request object 에서 post method 로 전송한 데이터의 구체적 내용을 확인하는데에 도움을 주며
그 밖에도 다른 많은 역할을 한다 
post 를 사용하는 함수에서 req.body 를 출력해보면 post 에 의한 데이터 전송값들을 구체적으로 보여준다.

30. express 의 코드를 html 에서도 연동시키기
express 코드 작성시에 :id 같은 변수를 routes 에 써왔는데,
이 코드 그대로 주소값을 넘기게 되면 html 이 이해를 못한다
그래서 routes.js 에서 obj 를 export 할 때,
${id} 와 같은 `` 코드를 이용하여 (백틱) 인자를 넘겨주고
if(id) {return `/users/${id} } else {return ~~}; 같은 형식으로 코드를 쓰게 되면
아이디가 존재 할때만 주소 값을 넘기도록 정의할 수 있다.

31. 정리
Router 는 어떤 주소에 대한 HTTP method 를 설정하는 공간이고,
controller 는 Router 에서 사용할 함수를 정의하는 공간이며, (라우터에서 매칭 시킨 주소와 부합하는 함수)
app.js 는 express 초기 환경 설정을 하는 공간이며,
init.js 는 express 막 실행 했을때 어떤 명령어가 들어오기도 전에 서버가 실행 가능 대기 상태로 가도록 만드는 것이고,
routes.js 는 매칭해줄 주소값만 정의해둔 공간 이며, 
views 는 express 에서 기본적으로 view template 의 엔진으로 매칭 되는 pug 파일의 저장공간 이며,
mixins 은 html 코드에서 계속 반복되는 코드를 복사 붙여넣기를 하지 않고, 함수를 통해서 처리하는 부분이며,
partials 은 pug 에서 겹치는 공통되는 부분을 따로 정의해둔 공간이다.

32. MongoDB
MongoDB 는 NoSQL 의 DB 로써 c++ 로 작성된 데이터베이스 이다
그렇기 때문에 node.js 와 연동 시키려면
mongoose 라는 object modeling 이 필요하다. (JDBC 비슷한거 같다)

MongoDB 의 장점은 빠른 속도에 있다
(DB 에서 말하는 Relationship 이 없는 경우에 적합한 데이터베이스 이다)

초기 셋팅 과정을 다음과 같이 한다
MongoDB 사이트에 가서 CE 버젼 다운 -> npm install mongoose -> npm install dotenv 
그리고 db.js 파일에 
import mongoose from "mongoose";
mongoose.connect("mongodb://localhost:portNumber/DBName", {});

같이 작성하면 기본 연결 설정을 할 수 있다
참고로 포트 번호는 mongod 명령어 작성하면 나온다.
{} 부분의 두번째 매개변수 부분은 mongoose 의 신 버젼과 구 버젼 사이의 충돌을 방지하기 위해서 작성하는 코드란이다.

또한 추가적으로

const db = mongoose.connection;

const handleOpen = () => console.log(" success ");
const handleError = (error) => console.log(` error : ${error}`);

db.once("open", handleOpen);
db.on("error", handleError);

같은 코드도 써줘서 연결 성공 시 함수, 실패 시 함수 를 구현해 준다.
또한 이를 처음에 import 할 때는 app.js 에서 import 를 한다 (app.js 가 express 설정 부분을 담당하는 코드이기 때문이다)

33. dotenv
dotenv 는 MongoDB 에서 자료를 숨기는데 도움을 주는 모듈이다.
localhost 에서 관리하면 상관 없지만 만약 프로젝트를 오픈소스 형식으로 만들어서 외부로 넘긴다면 
정보 유출의 우려가 있을 수도 있기 때문에 이런것을 방지하기 위해서 dotenv 를 사용한다. 

예를 들면, db.js 에서 초기 설정때, mongodb://localhost:portNumber ~ 같은 식으로 경로를 작성했는데
이보다는 .env 파일을 별도로 만들어서, MONGO_URL=~ 같은 변수를 만들어서 보호 할 수 있다.

34. MongoDB 파일 경로 지정
MongoDB 에서 사용할 데이터를 담는 파일의 위치를 선정하기 위해서
models 라는 폴더를 만들었으며 그 안에 DB 에 담길 파일에 대한 정보를 저장한다.

MongoDB 의 특이한 점은 파일의 bytes 를 담아서 저장하는게 아니라
file 의 주소 (url) 을 DB 에 넣는 다는 점이다
보안성의 문제도 있지만, bytes 를 넣게 될 경우 (특히 미디어 파일 일 경우) DB 의 데이터 크기가 상당히 커지게 된다.

35. Video.js 내용 설명
이 파일에선 다음과 같은 내용들을 설정하게 된다

- schema
: fileUrl 을 props 로 두고 JSON 형식으로 파일 경로의 타입 (type : string) 문자열로 설정하고
required 는 파일 경로가 잘못 설정 되었거나, 아예 지정되지 않은 경우 나타내줄 에러 메시지를 말한다.

이 스키마 영역에는 비디오 정보 관련된 JSON 형식의 값을 넣도록 되어 있다.
그래서 이 프로젝트에서는 파일의 경로와 비디오의 제목과 비디오 설명, 비디오 뷰 수 등 여러 정보를 넣는다.

schema 에 들어 갈 수 있는 props 를 알기 위해서는 mongoose API docs 참조

참고) mongoose 에서 schema 란
MongoDB 처럼 테이블이 없는 데이터베이스는 데이터베이스에 아무 값이나 막 넣어도 다 들어간다 (스키마를 통한 제제가 없을 때)
그래서, 이를 아무 값이나 막 들어가는 것을 방지하기 위해서 스키마라는 일종의 규약 같은게 필요하고
스키마의 규정에 부합하지 않는 대상이 입력될 경우 데이터베이스에 저장되지 않는다.
(한마디로, 스키마는 데이터베이스 테이블에서 필드와 동일하다)

mongoose 에서 model 이란 
spring boot 에서 domain layer 에 저장되는 class 와 비슷한거 같다.

36. Relationship 정의
두 스키마 간에 Relationship 을 정의하는 방법은
Primary key 인 id 값을 이용하는 것이다.
video.js 가 comment.js 의 각 id 를 배열 형태로 갖거나
혹은 comment.js 가 video.js 의 id 값을 가지고 있어서, 서로 연계시키는 방법을 채택해야 한다

- 1. Video.js 가 Commnet.js 에 대한 관계형식을 갖는 경우

comments : [{
    type: mongoose.Schema.Types.ObjectId, // 타입은 다른 스키마의 id 를 가져오는 형식으로
    ref: "Comment" // ref 는 파일명이며 (모델명을 넘겨주는게 아님) 경로 설정에 주의 해야함
}]

이 방식에서 array 내부에 obj 를 넣는 이유는 
한 비디오에는 여러 개의 comment 가 들어 갈 수 있기 때문에 array 방식을 쓴것.

- 2. Comment.js 에 Video.js 관계형식을 갖는 경우

video : {
    type:mongoose.Schema.Types.ObjectId,
    ref:"Video"
}

마찬가지로 ref 는 파일명, type 은 아이디 이며,
각 코멘트가 어떤 비디오의 아이디에 매칭되는지를 선정하는 방식이다.

참고) 스키마를 정의할때, (Video.js 에서) fileUrl, title 과 같은 이름은 테이블의 필드명과 동일함
그 필드명 하위의 obj 를 선정하는데 그때의 props 는 mongoose 에서 지정한 선택자로 정의 된다.

37. async
JS 는 기본적으로 함수형 프로그래밍이긴 하지만
비동기를 지원한다.
비동기란 어느 한 코드가 끝나고 다음 코드가 실행되는 순차적 실행이 아니라 
어느 한 코드가 실행이 끝나기 전에 다음 줄의 코드를 실행하는 방식이다.
웹은 항상 실시간으로 데이터 전송이 이뤄져야 의미가 있기 때문이다.
그래서 웹 프로그래밍을 할때 어떤 부분은 반드시 실행 되고 나서 다음 작업을 해야 된다 라고 명시하려면
async 키워드를 써줌으로써 그 코드는 반드시 실행이 끝나고 다음 코드로 가야된다를 명시해 줄 수 있다.

함수에 async 를 쓰게 되면 이 함수는 동기화 작업을 해야 된다 라는 것이고,
await 키워드를 같이 쓰게 되는데, await 가 작성된 코드는 그 코드가 끝나고 나서 다음 코드로 넘어가라는 의미이다.

await 로 작성한 코드는 코드의 실행 성공 여부와 무관하게 코드의 실행이 끝나기만 하면 무조건 다음 코드로 넘어간다
그래서 만약 await 로 작성한 코드가 오류가 발생하게 되더라도 다음 코드로 넘어가게된다
그래서 예외처리가 필요하다.

DB 에서 await 처리로 변수를 생성할 때에는 ( const video = await DBFileName.find({}); ) 그 변수 (video) 의 내용은
일반적으로 array 로 들어간다

38. 업로드 파일 제한
특정 형식의 파일만을 받게 해주기 위해서 제한을 걸려면
JS 에서 처리를하는 것이 아니라 pug 의 form 태그 하위의 input 에서 accept="video/*" 같이 조건을 달아야 한다.

39. 파일 업로드
파일 업로드 할 때는 byte 가 아닌 파일의 경로 URL 을 넘겨줘야 하기 때문에
middleware 를 하나 새로 만들고 그것을 담는 파일을 만들어야 한다.
이 역할을 하는 middleware를 multer 라고 한다

npm install multer 를 해주고
app.post 함수에 인자로 upload.single() (또는 .array(), fields())
를 추가해주면 리턴 값으로 파일의 URL 을 리턴함

또한 upload form 에 enctype="multipart/form-data" 를 props 로 추가

40. 정리
app.post 메소드를 활용하는 컨트롤러에서 req.body 를 하게 되면 
post 메소드를 사용하는 form 태그 내부의 정보를 리턴하고 (보통 input tag 의 name 을 리턴함)
file: {path} 는 multer 가 제공하는 메소드 이다.
mongoose 를 통해서 만든 스키마JS 파일로 create 메소드를 실행하면 스키마에 저장될 내용을 정할 수 있게 된다.

schema : DB 에 넣을 값에 대한 테이블 필드 정의하는 곳
model : schema 를 통해 document 를 만드는 생성자, 이 모델을 정의함으로 써 document 라는 instance 가 생성된다.
document : document 는 model 에 의해 생성된 instance 이다.
multer : 파일 업로드를 위한 middleware 이다. 
const fileURL = multer({ dest: "URLName/" }); // 파일에 대한 정보가 저장될 경로를 선정
export const fileUpload = fileURL.single("fieldName"); // 파일을 하나만 올리도록 정의하고, form 태그에서 필드 네임에 맞춰서 업로드 해주는 변수
pug 에서 routes 를 따로 import 해주지 않은 이유는 middlewares.js 때문이다.
middlewares.js 에서 res.locals.변수명 이 모든 하위 레이어에서 쓰이도록 전역 미들웨어로 정의 했기 때문이다 (app.js 참조)

mongo cmd 에 접속하고 나서 show collections 로 collection 을 확인할 수 있는데
이때 collection 은 model 과 같은 의미라고 한다 (document 의 집합)

41. (3 - 7 강)
지금 까지는 파일의 path 를 통해서 로컬 서버에 비디오의 byte 를 저장하였다
그러나 이런 방식으로 서버를 작성하게 되면, 로컬 서버가 아닌 다른 서버를 만들때
업로드 했었던 파일들을 복사 붙여넣기 하여서, 다른 서버로 옮겨줘야 하는 번거로움이 있다.
그래서 후반부 강의에서는 AWS 를 통해서 amazon cloud 서버에 파일을 업로드하고
그 클라우드 서버로부터 파일의 경로만을 받아와서 구현을 하는 방식으로 바꿔야한다.

42. pug 에서 model 데이터를 사용하여 불러오기
video_detail.pug 에서 video 태그 의 src=`/${video.fileUrl}` 로 설정한 이유는
서버에서 데이터를 읽어오고 처리할때 서버의 루트 주소를 기반으로 모델명 video 에 접근해라 라는 의미이기 때문이다.
이전까지는 pug 에 데이터 src 를 지정할때 로컬 스토리지 에서 가져왔기 때문에 백틱을 쓰지 않았고 루트 (/) 도 붙이지 않았다.

43. getEditVideo, postEditVideo
getEditVideo 는 어떤 비디오의 아이디를 찾아서 그 내용을 랜더링 하는 작업 
postEditVideo 는 어떤 비디오에 대한 상세 정보를 업데이트 하는 작업 으로 정의하였다.

항상 무엇을 정의하는지 그 로직을 명확하게 잡고 코드를 짜야함

44. JS 의 장점이자 단점
videoControllers.js 에서 
await Video.findOneAndUpdate 를 할 때 
{_id: id} 와 같은 obj 형식의 값을 넣어 줬다
이 객체에서 좌측의 값은 mongoose 의 스키마의 필드 값이며,
오른쪽의 id 는 새로 넣은 변수 값이다.

그런데, 스키마의 필드값과 value 에 해당하는 오른쪽 값의 변수명이 서로 동일하면
title:title 과 같이 쓰지 않고 하나로 title 이라고만 써도 같은 효과를 발휘한다

코드 작성에는 매우 편한거 같은데 
남이 이렇게 쓰면 굉장히 리뷰하기 힘들어보인다.

45. search
아무런 조건없이 await Video.find({}) 를 하게 되면
먼저 넣은 데이터가 먼저 나오는 큐 와 같은 자료구조로 나오게 된다.
그래서 순서를 스택 처럼 바꾸고 싶다면 
find({}).sort({ _id: -1}) 로 하면
아이디를 역순으로 find 하겠다는 의미이다.

46. ESLint
ESLint 란 자바스크립트 코드를 작성할때, 코드가 잘못되었거나, 오류를 유발할 가능성을 주거나 하는 등의 
코드상에 문제가 발생할 만 한 대상에 미리 IDE 가 경고를 하도록 돕는 패키지 이다.

설치는 아래 방식으로 
way I solve the problem. when eslint global doesnt work

1. remove if you installed eslint globally  $ npm uninstall eslint -g

2. install  eslint extension on vscode
https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint

3.  install 3 packages manually, not by command on eslint installed globally, 
$ yarn add eslint-config-airbnb-base eslint eslint-plugin-import

4. make .eslintrc.js file and copy paste codes below
module.exports = {
  env: {
    browser: true,
    es6: true,
    node: true
  },
  extends: "airbnb-base",
  globals: {
    Atomics: "readonly",
    SharedArrayBuffer: "readonly"
  },
  parserOptions: {
    ecmaVersion: 2018,
    sourceType: "module"
  },
  rules: {}
};

5. install eslint-config-prettier $yarn add eslint-config-prettier

6. go to .eslintrc.js file and change "extends" from   "airbnb-base", to ["airbnb-base", "prettier"],

7. go to app.js and try save by ctrl+s  then you will see red lines if eslint activates succesfully

(npm 에서 -g 는 global 의 약어로 현재 프로젝트에서만 설치를 하는게 아니라 로컬의 어떤 프로젝트든지 사용하도록 하는것)

설치 후에 
eslint --init 을 하면 eslint 의 초기 설정을 지정해 줄 수 있다.

(format on save 를 하게 되면 preitter 에 의해서 저장 할 때 마다 파일들을 포맷 해준다, preitter 설치하면 기본으로 설정해주는것 같다)

47. 일부만 검색
검색할때 일부 글자만 보고 그것이 들어간 모든 대상을 찾을때
정규식을 이용한다. 
express 에서는 정규식을 사용할 때 
$regex:statement 같은 구문으로 정의를 한다.

그리고 위의 정규식에서 어떤 옵션을 추가해 주고자 하는 경우
, $options:~ 같이 써준다
옵션 값으로 "i" 가 들어가는 경우 insensitive 의 약어로 대소문자 구분을 하지 않는다는 뜻이다.

videoControllers 에서 search 부분의 함수를 let videos = [] 로 선언한 것은 
특정 값을 검색으로 찾을 때마다 변경시켜주기 위함이다 (const 의 경우 상수 여서 이를 막기 위함임)

48. webpack
webpack 은 ES6 JS 나 sass 등 여러 파일들을 고전적인 JS 나 css 등으로 통합 변환 시켜주는 
module bundler 이다 (ES6 등 여러 modern 한 파일들을 static file 로 변환 시킴)

npm install webpack webpack-cli 로 설치한다

webpack 은 기본 패키지로 파일을 변환 시키는데 사용하고
webpack-cli 는 커맨드 라인 환경에서 쓰기 위함이다.

package.json 에 
npm start 대신 앞으로는 
"dev:server":" 기존 npm start 내용 "
"dev:assets":" webpack " 
으로 바꿔서 실행한다.

webpack 은 서버 코드와 별도로 돌아가야만 하는 코드이기 때문에
기존 서버 코드 작성시에 사용했던 
nodemon babel 등 은 사용되지 않는다
그래서 webpack.config.js 파일을 작성 할 때는 구 자바스크립트 코드를 써야한다.

webpack 에는 두가지 요소가 존재한다
 - 1. entry
 :  어디에서 파일이 왔는지를 명시하는 것
 - 2. output
 : entry 에서 온 파일을 어디에 넣을 것인가를 묻는것.


49. node.js 에서 파일과 경로를 absoulte 하게 만드는 방법 (absoulte : 절대 경로 (모든 경로를 다 표시하는 방식))
nodejs 에 기본적으로 깔려있는 path 라는 모듈을 활용하여 정의 할 수 있다.
webpack.config.js 에 const path = require('path'); 를 정의 한다 ( import path from "path"; 와 동일 )

__dirname : 현 디렉토리의 주소 값 (nodejs 에서 제공하는 환경 변수)


50. webpack.config.js 추가 설정
package.json 에 script 부분에 다음과 같은 코드를 추가한다.

"dev:assets":"WEBPACK_ENV=development webpack",
"build:assets":"WEBPACK_ENV=production webpack"

WEBPACK_ENV=production 은 서버에 코드를 올리는 것이고
WEBPACK_ENV=development 는 로컬에서 환경설정을 위한 코드 이다.

webpack 에 아무런 설정을 해주지 않으면
scss 코드를 이해하지 못한다
그래서 webpack 설정 파일에서 
module: {
    rules: [
        {
            test: /\.(scss)$/       // scss 파일을 모두 찾아라 라는 의미
            use:        // 찾은 파일을 css 로 바꿔라 라는 의미
        }
    ]
}

에 다가 scss 를 이해할 수 있게
loader 를 실어 준다 
loader 란 webpack 에게 파일을 어떻게 처리할지에 대한 방법을 주는 역할을 한다.

loader 에 정의를 내릴 때는 정규 표현식으로 쓴다.

위에서 rules : [ { use: ~~}] 를 사용할 때 
npm install extract-text-webpack-plugin@next 를 사용해
필요한 패키지를 미리 설치해 놔야 한다.
(extract-text-webpack-plugin)

npm 에서 @next 는 다음의 최신 버젼을 깔으란 뜻이고
@2.3 같이 쓰면 2.3 버젼을 다운 받아라 라는 뜻이다.

 use: ExtractCSS.extract([
          {
            loader: "css-loader"
          },
          {
            loader: "postcss-loader"
          },
          {
            loader: "sass-loader"
          }
        ])

부분은 순차적으로 코드가 실행되는게 아니라
아래에서 부터 위로 실행 된다
즉, sass 부터 로더에 싣고 postcss, css 순으로 올린다.

sass-loader 는 scss 파일을 로더를 통해서 css 파일로 옮겨 주고
postcss-loader 는 css 관련된 plugin 들 을 로더에 담아 처리(실행)해주며 (컴파일 비슷한듯)
css-loader 는 마지막으로 여러 로더를 거쳐서 옮겨진 css 를 최종적으로 정리하여 loader 에 담아주며
ExtractCSS 로 loader 에 올라간 css 파일의 유효한 코드만 추출하여 따로 빼내는 작업을 한다.

postcss 는 css 코드 작성 시에 자동완성을 도와주거나, 브라우저 별 호환성에 맞게 자동변환 해준다던가 
아니면 eslint 처럼 오류 사항에 대해서 알림을 주는 그런 도구다.

autoprefixer 의 browsers 옵션은 
어느 브라우저에서 호환성을 어떻게 맞출 것인가 에 대한 설정을 해주는 코드다
뭐 예를 들면 크롬 몇 버젼 이상 부터만 사용가능하게 한다 던지
cover 99.5% 는 99.5% 에 해당하는 거의 모든 대상에게 적용시킨다 라는 뜻이다.

51. scss 에서 변수 선언
$name: value; 형태로 선언한다.

52. 윈도우 CLI 환경변수 설정 문제
맥os 와는 다르게 윈도우 환경에서는 환경 변수 설정을 위한 작업이 번거롭다 (패키지 매니저가 따로 있긴 하지만 일반 cmd 에선 안 먹힘)
그래서 복잡한 환경 설정 문제를 해결하고자, 
cross-env 라는 패키지를 설치해 주면 이 문제를 해결 할 수 있다.

참조 : www.npmjs.com/package/cross-env

53. dev:assets 옵션
-w 는 css 파일을 수정할때마다 webpack 이 파일들을 watch 하여 변화가 있을때마다 탐지하는 방식 (변화 있으면 webpack 을 재실행 알아서함)

54. app.use("/uploads", express.static("uploads")); 의미 
이 구문의 의미는 express 서버에게 
/uploads 주소를 사용할 건데 이 주소에는 uploads 라는 이름의 static resource 가 있으니 
이를 활용해라 라고 알려주는 것.
즉 이 프로젝트 전체에서 /uploads 라는 주소를 쓰게 되면 알아서 express 가 uploads 의 폴더로 찾아가라 라는 의미이다.

55. webpack 에 대한 정리

entry : 웹팩이 접근할 파일 경로를 지정해줌 
const ENTRY_FILE = path.resolve(__dirname, "assets", "js", "main.js");

mode(=production=development) : 환경변수를 설정하는 것 같다

module : webpack 에서 사용할 각 파일별 loader 를 설정해준다.

output : webpack 에 의한 빌드로 생성된 파일들의 결과물을 어디에 저장할지 선정해준다

56. regenerator runtime error 
지금은 버젼이 달라서 안뜨는 오류 인것 같지만,
위 오류가 뜨면 @babel/polyfill 를 설치하여 해결한다.
(이 패키지는 js 에서 사용이 안되는? 그런 메소드들을 사용하게 돕는거 같다)

57. scss 의 문법 장점
 - 1. 부모 selector 안에 자식 selector 를 넣어서 설정할 수 있다
  기존에는 .father .child 이런 식으로 해야 햇는데 
  .father {
    .child {

    }
  }
  형식으로 정의가 가능하다 (더 명확하게 상속관계를 보여줌)
 - 2. & 문법의 추가
   & 는 현재 selector 에서 탐색한다는 의미이다.
   &:last-child 는 현 selector 의 마지막 자식 selector 를 찾는다는 의미
   또한 &::placeholder 를 하게 되면 현 selector 에서 placeholder 값을 
   바꾸겠다는 의미로 해석 된다.
 - 3. 전역 변수의 선언
   _variables.scss 를 보면 $name : value; 형식으로 선언 되었다.
   이렇게 선언하고 쓰면 모든 scss 에서 사용가능한 전역 변수가 된다. 


58. --ignore 'scss'
dev:server 에 이 코드를 추가한 이유는 nodemon 이 scss 파일을 수정할때마다
업로드 해야하는 대상으로 인식하기 때문에 막아주기 위해서 추가함

59. passport.js & cookie
passport.js 는 홈페이지 제작시에 사용자 인증을 가능하게 돕는 js 모듈이다.

cookie 는 브라우저에서 개발자 툴에서 applicaiton 에서 내용을 볼 수 있으며 (크롬 기준)
쿠키는 보통 request 에 대응하는 정보들을 백엔드 부분으로 넘겨주기 위한 데이터들이 저장되어 있다.

passport.js 는 이 쿠키를 활용하여 진행되는데
먼저 필요한 쿠키를 생성하여 브라우저에 저장시키고, 유저에게 넘겨주며, 백엔드로 넘겨주는 역할을 한다.

60. passport-local-mongoose
이 모듈은 User 라는 model 을 만드는데 도움을 주는 모듈로 
패스워드 변경, 암호화, 확인 등 여러 보안적인 작업에 도움을 줌과 동시에
passport.js 와 같이 인증을 할 수 있도록 돕는다.